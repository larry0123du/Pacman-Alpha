<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
        <link rel="stylesheet" href="css/styles.css">
        <!-- <script type="text/javascript" href="js/binarySearch.js"></script> -->
	</head>
	<body>
		<canvas id="gc"></canvas>
		<script>
        const gs=20; // size of one grid
        const rad = 0.5*gs;
        var realWidth, realHeight;
        var border;

        var px, py; // Starting position of Pacman. Note that in this system, x is the col number and y is the row number
        var mouthClose = false;

        // const foodGrid = Array(2048).fill(1);
        var walls;
        var gridWidth, gridHeight;

        var gameState;
        var score = 0;

        SCARED_TIMER = 60; // Set the scared time
        // define directions
        var dirs = {
            SOUTH: {x:0, y:-1},
            NORTH: {x:0, y:1},
            EAST: {x:1, y:0},
            WEST: {x:-1, y:0}
        };

		window.onload=function() {
			canv=document.getElementById("gc");
			canv.width = window.innerWidth;
			canv.height = window.innerHeight;
		
			ctx=canv.getContext("2d");
            document.addEventListener("keydown",keyPush);
            init();
			setInterval(game,600);
		}

        xv=yv=0; // Initial Velocity

        function Character(id, pos, speed) {
            this.id = id;
            this.initPos = pos;
            this.pos = pos;
            this.initSpeed = speed;
            this.speed = speed;

            function getPos() {return this.pos;}

            function move(dir) {
                this.pos.x += dir.x;
                this.pos.y += dir.y;
            }

            function doubleSpeed(){this.speed *= 2;}

            function halfSpeed() {this.speed /= 2;}

            function reset() {
                this.pos = this.initPos;
                this.speed = initSpeed;
            }
        }
        
        function Ghost(id, pos, speed, frightened, color) {
            Character.call(this, id, pos, speed);
            
            this.frightened = frightened;
            this.timer = 0;
            this.initColor = color;
            this.color = color;

            function reset() {
                Character.prototype.reset.call(this);
                this.timer = 0;
                this.frightened = false;
                this.color = this.initColor;
            }

            function scare() {
                this.frightened = true;
                this.timer = SCARED_TIMER;
                this.color = 'blue';
            }

            function isScared() {
                return this.scared;
            }

            function decrementTimer() {
                this.timer--;
                if (this.timer == 0) {
                    this.color = this.initColor;
                    this.frightened = false;
                }
            }
        }

        function Pacman(id, pos, speed) {
            Character.call(this, id, pos, speed);
            this.lives = 3;

            function decrementLives() {
                this.lives--;
            }

            function alive() {
                return this.lives > 0;
            }
        }

        function init() {
            ctx.fillStyle="black";
            ctx.fillRect(0,0,canv.width,canv.height);
            realWidth = Math.floor(canv.width/gs) * gs;
            realHeight = Math.floor(canv.height/gs) * gs;
            border = {
                left:2.5*gs,
                right:realWidth - 2.5*gs,
                top:2.5*gs,
                bottom:realHeight - 2.5*gs
            };
            gridWidth = (border.right - border.left)/gs - 1;
            gridHeight = (border.bottom - border.top)/gs - 1;

            gameState = Array(gridHeight).fill().map(
                () => Array(gridWidth).fill('F'));

            ctx.strokeStyle="white";
            // substantiate the walls
            walls = [
                // starts (1, 2)
                {
                    x: 1,
                    y: 0,
                    width: 1,
                    length: 5
                },
                {
                    x: 10,
                    y: 8,
                    width: 1,
                    length: 10
                }
            ];
            
            roundedRect(border.left - gs/2, border.top - gs/2, border.right - border.left + gs, border.bottom - border.top + gs, gs);
            roundedRect(border.left, border.top, border.right - border.left, border.bottom - border.top, gs);
            px = 0;
            py = 0;

            drawPacman(px, py);
            drawWalls();
            drawFoods();
            // ctx.moveTo()
        }
        function drawFoods() {
            // starting from the top-left corner
            let current_pos = {x:border.left + gs, y:border.top + gs};
            ctx.fillStyle = "white";
            ctx.beginPath();
            
            for (var i = 0; i < gameState.length; i++) {
                for (var j = 0; j < gameState[i].length; j++) {
                    if (gameState[i][j] === 'F') {
                        ctx.moveTo(current_pos.x + j*gs, current_pos.y + i*gs);
                        ctx.arc(current_pos.x + j*gs, current_pos.y + i*gs, rad/4, 0, 2*Math.PI, false);
                        ctx.fill();
                    }
                }
            }
        }
        function drawWalls() {
            off_x = border.left;
            off_y = border.top;

            ctx.beginPath();
            ctx.fillStyle="black";
            ctx.strokeStyle="white";
            for (var i = 0; i < walls.length; i++) {
                let curr_x = off_x + (walls[i].x + 1) * gs;
                let curr_y = off_y + (walls[i].y + 1) * gs;

                ctx.moveTo(curr_x, curr_y);
                ctx.fillRect(curr_x - gs/2, curr_y - gs/2, walls[i].width*gs, walls[i].length*gs);
                roundedRect(curr_x - gs/3
                , curr_y - gs/3, 
                walls[i].width * gs - gs/3,
                walls[i].length * gs - gs/3,
                walls[i].width * gs/5);

                for (var k = 0; k < walls[i].length; k++) {
                    for (var j = 0; j < walls[i].width; j++) {
                        gameState[walls[i].y + k][walls[i].x + j] = 'W';
                    }
                }
            }
        }

        function isWall(x, y) {
            if (gameState[x][y] === 'W') return true;
            return false;
        }
        
        function isFood(x, y) {
            return gameState[x][y] === 'F';
        }

        function drawPacman(x, y, mouthClose=false) {
            gameState[py][px] = 'N';
            ctx.fillStyle="yellow";
            ctx.beginPath();
            var startingAngle;
            var endAngle;
            // if (mouthClose) {
            startingAngle = 0;
            endAngle = 2*Math.PI;
            // }
            // else {
            // startingAngle = Math.PI / 7;
            // endAngle = -Math.PI / 7;
            // }
            real_x = border.left + (x + 1) * gs;
            real_y = border.top + (y + 1) * gs;
            ctx.moveTo(real_x, real_y);
            ctx.arc(real_x, real_y, rad, startingAngle, endAngle, false);
            
            // ctx.lineTo(x - rad, x);
            ctx.fill();
        }
        function undrawPacman(x, y) {
            ctx.strokeStyle="black";
            ctx.fillStyle = "black";
            ctx.beginPath();
            real_x = border.left + (x + 1) * gs;
            real_y = border.top + (y + 1) * gs;
            ctx.moveTo(real_x, real_y);
            ctx.arc(real_x, real_y, rad, 0, 2*Math.PI, false);
            ctx.stroke();
            ctx.fill();
        }

        function roundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x, y + radius);
            ctx.lineTo(x, y + height - radius);
            ctx.arcTo(x, y + height, x + radius, y + height, radius);
            ctx.lineTo(x + width - radius, y + height);
            ctx.arcTo(x + width, y + height, x + width, y + height-radius, radius);
            ctx.lineTo(x + width, y + radius);
            ctx.arcTo(x + width, y, x + width - radius, y, radius);
            ctx.lineTo(x + radius, y);
            ctx.arcTo(x, y, x, y + radius, radius);
            ctx.stroke();
        }
        
		function game() {
            console.log(score);
            // if (mouthClose == true) {
            //     mouthClose = false;
            // }
            // else {
            //     mouthClose = true;
            // }
            undrawPacman(px, py);
            if (px + xv < 0 || px + xv >= gridWidth) {
                xv = 0;
            }
            if (py + yv < 0 || py + yv >= gridHeight) {
                yv = 0;
            }
            if (isWall(py + yv, px + xv)) {
                xv = 0;
                yv = 0;
            }
            
            px += xv;
            py += yv;

            if (isFood(py, px)) {
                score += 100;
            }

            drawPacman(px, py, mouthClose);
        }

        function keyPush(evt) {
			switch(evt.keyCode) {
				case 37:
					xv=-1;yv=0;
					break;
				case 38:
					xv=0;yv=-1;
					break;
				case 39:
					xv=1;yv=0;
					break;
				case 40:
					xv=0;yv=1;
					break;
			}
		}
		</script>
	</body>
	
</html>
